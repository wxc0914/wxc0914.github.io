---
title: 面向对象
date: 2021-05-05 13:32:50
categories:
- Java
tags:
---

#### 面向对象程序设计

传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的方式。而面向对象程序设计(OOP)却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。

#### 类、对象

每个方法都有两个参数。第一个参数称为隐式参数（implicit），是出现在方法名前的类对象。第二个参数位于方法名后面括号中的数值，这是一个显示参数（explicit）。在每一个方法中，关键字`this`表示隐式参数。

修饰符 | 可见范围
-| -
private | 仅对本类可见
public | 对所有类可见
protected | 对本包和所有子类（子类可能不在本包中）可见
无修饰符 | 对本包可见

#### 重写、重载

重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 

重写是子类对父类的方法进行重新编写，返回值和形参都不能改变。重载是对同一个类里面的方法进行重新编写，方法名字相同，而参数不同，返回类型可以相同，也可以不同。

重写规则：
+ 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。
+ 访问权限不能比父类中被重写的方法的访问权限更低（里氏替换原则）。
+ 声明为final或者static的方法不能被重写。
+ 子类和父类在同一个包中，那么子类可以重写父类的所有方法，除了声明为private和final的方法；子类和父类不在同一个包中，那么子类只能够重写父类声明为public和pretected方法。
+ 重写方法可以抛出新的非强制异常。

重载规则：
+ 被重载的方法可以声明新的或更广的检查异常。
+ 方法的签名：指出方法名以及参数类型。所以，不能有两个名字相同，参数类型也相同却返回不同类型值的方法。

#### 自动拆箱、自动装箱

该过程时编译器在生成类的字节码时，插入必要的方法调用，虚拟机执行这些字节码。

装箱：将基本类型用他们对应的引用类型包装起来。

拆箱：将包装类型转换为基本数据类型。

#### 接口、抽象类

```java
public interface 接口名称 {
    public static final 变量类型 变量名 = 变量值; // Java7
    public abstract 返回值类型 方法名称(参数列表); // Java7
    public default 返回值类型 方法名称(参数列表) {} // Java8
	public static 返回值类型 方法名称(参数列表) {} // Java8
    private 返回值类型 方法名称(参数列表) {} // Java9
    private static 返回值类型 方法名称(参数列表) {} // Java9
}
```
#### 拷贝

深拷贝和浅拷贝的区别是：浅拷贝的对象，当我们改变原对象的值的时候，拷贝的对象值也会发生变化。
目前，常用的深拷贝方法如下：

+ 利用构造方法，形参如果是基本类型和字符串则直接赋值，如果是对象则重新new一个。
+ 子类重写`Object`类的`clone()`的拷贝方法，并修改为`public`类型。除此之外，子类还需要实现`Cloneable`接口来告诉`JVM`这个类是可以拷贝的。
+ 将源对象进行序列化，再反序列化生成拷贝对象。

#### Object

**equals**

所有的equals都必须满足下面五个特性：

+ 自反性：`x.equals(x) == true`
+ 对称性：`x.equals(y) == y.equals(x)`
+ 一致性：反复调用结果不变
+ 传递性： `x.equals(y)`、`x.equals(z)` => `y.equals(z)`
+ `x.equals(null) == false`

因此，在设计equals函数时必须要满足上面五个特性，同时也借助以下两个特点：

+ 如果子类能够拥有自己的相等的概念，则对称需求强制采用`getClass`进行检测。
+ 如果由超类决定相等的概念（不同的子类之间进行相等的比较），那么就可以使用`instanceof`进行检测。

**hashcode**

由于`hashCode`方法定义在`Object`类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

#### 枚举类

`enum Size {SMALL, MEDIUM, LARGE}`

+ 所有的枚举类型都是`Enum`类的子类。

+ `toString`方法能够返回枚举常量名。

+ 每个枚举类型都有一个静态的`values`，他将返回一个包含全部枚举值的数组。