---
title: 锁
date: 2021-05-05 13:32:50
categories: 
- Java
tags:
---

## 乐观锁、悲观锁

乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。

#### 乐观锁

对于同一个数据的并发操作，乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁。

乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法 。

```java
// java.util.concurrent包中的原子类就是通过CAS来实现类乐观锁

// AtomicInteger类的自增函数底层调用的是Unsafe类中的getAndAddInt()
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// 该方法实际上就是CAS，而它的底层调用的是一个native方法：compareAndSwapInt
public final int getAndAddInt(Object o, long offset, int delta) {
    int v;
    do {
        v = getIntVolatile(o, offset);
    } while (!compareAndSwapInt(o, offset, v, v + delta));
    return v;
}

// 该方法是借助于CPU的cmpxchg完成的，属于原子操作
public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);
```

**ABA问题：**

描述：CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的 。

解决思路：变量前加版本号

#### 悲观锁

对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。

Java中，synchronized关键字和Lock的实现类都是悲观锁。 

## 自旋锁、适应性自旋锁

如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋）。

#### 自旋锁

自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作。

#### 适应性自旋锁

自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 

## 无锁、偏向锁、轻量级锁、重量级锁

#### 无锁

无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。 

#### 偏向锁

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。 

偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。 

#### 轻量级锁

是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。 

而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。 

#### 重量级锁

Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。 

## 公平锁、非公平锁

#### 公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。 

#### 非公平锁

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。 

在ReentrantLock中，公平锁和非公平所在获取锁时，唯一的区别是：公平锁会调用hasQueuedPredecessors，判断当前线程是否处于队首。

```java
public final boolean hasQueuedPredecessors() {
    Node t = tail;
    Node h = head;
    Node s;
    return h != t && ((s = h.next) == null || s.thread != Thread.currentThread());
}
```

## 可重入锁、非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。 

Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。 

ReentrantLock继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。 

当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。 

```java
// 可重入锁加锁过程
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}

//可重入锁释放锁过程
protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
```

## 独享锁、共享锁

独享锁和共享锁同样是一种概念。 

独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。  如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。 JDK中的synchronized和JUC中Lock的实现类就是互斥锁。 

```java
// 获取写锁
protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState(); // 写锁个数
    int w = exclusiveCount(c); // 读锁个数
    if (c != 0) {
        if (w == 0 || current != getExclusiveOwnerThread()) // 存在读线程、持有锁的线程不是当前线程
            return false;
        if (w + exclusiveCount(acquires) > MAX_COUNT) // 写锁数量大于2^16-1
            throw new Error("Maximum lock count exceeded");
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) // 写线程需要阻塞、CAS失败
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
```



共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。 

```java
// 获取读锁
protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState(); // 写锁个数
    if (exclusiveCount(c) != 0 && getExclusiveOwnerThread() != current) // 存在写线程、持有锁的线程不是当前线程
        return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() && r < MAX_COUNT && compareAndSetState(c, c + SHARED_UNIT)) {
        if (r == 0) {
            firstReader = current;
            firstReaderHoldCount = 1;
        } else if (firstReader == current) {
            firstReaderHoldCount++;
        } else {
            HoldCounter rh = cachedHoldCounter;
            if (rh == null || rh.tid != getThreadId(current))
                cachedHoldCounter = rh = readHolds.get();
            else if (rh.count == 0)
                readHolds.set(rh);
            rh.count++;
        }
        return 1;
    }
    return fullTryAcquireShared(current);
}
```

