---
title: 多线程
date: 2021-04-05 13:32:50
categories: 
- Java
tags:
---

#### 进程、线程

进程是一次程序的执行过程、是系统程序运行的基本单位。线程是比进程更小的执行单位，与进程不同的是，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器 、虚拟机栈、本地方法栈。



进程五状：创建、就绪、执行、阻塞、终止

处理机调度：高级调度、中级调度、低级调度

进程调度（低级调度）： 按照一定策略选择就绪进程，占用cpu执行。 

批处理系统

+ 剥夺式：
    + 最短剩余时间优先（SRTN）
    + 最高响应比优先（HSRF）
+ 非剥夺方：
    + 先来先服务（FCFS）
    + 短作业优先（SJF）

交互式系统

+ 时间片轮转
+ 优先级调度
+ 多级反馈队列



产生死锁的四个必要条件：

+ 互斥

+ 请求和保持
+ 不剥夺
+ 循环等待

产生死锁的原因

+ 竞争不可抢占资源
+ 竞争可消耗资源
+ 进程推进顺序不当

解决死锁的基本方法：

+ 破坏请求和保持条件
+ 破坏不可抢占条件
+ 破坏循环等待条件

避免死锁的算法：

+ 线性资源分配法
+ 系统安全状态法
+ 银行家算法
    + 可利用资源向量Available
    + 最大需求矩阵Max
    + 分配矩阵Allocation
    + 需求矩阵Need

#### sleep()、wait()的区别

+ `sleep()`没有释放锁，而`wait()`释放了锁
+ `wait()`通常被用于线程间交互/通信，`sleep()`通常用于暂停执行。
+ `wait()`被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的`notify()`或者`notifyAll()`。`sleep()`执行完成后，线程会自动苏醒。或者可以使用`wait（long timeout）`超时后线程会自动苏醒。

#### synchronized

用于保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

自旋锁、适应性自旋锁、锁消除、锁粗话、锁偏向、轻量级锁

#### CAS

#### Atomic



单例模式

懒汉式

```java
public class Singleton {
    private static Singleton instance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
    	return instance;
    }
}
```



线程安全的懒汉式

```java
public class Singleton {
    private volatile static Singleton instance = null;
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) {
        	synchronized(Singleton.class) {
                if (instance == null) instance = new Singleton();
            }
        }
    	return instance;
    }
}
```





饿汉式

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() {
        return instance;
    }
}
```

