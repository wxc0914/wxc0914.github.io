---
title: 异常处理
date: 2021-04-05 13:32:50
categories:
- Java
tags:
---

### 异常

### 异常分类
异常对象都是派生于Throwable类的一个实例，如果Java中内置的异常类不能够满足需求，用户还可以创建自己的异常类。

`Throwable`的下一层被分为`Error`和`Exception`。`Exception`的下一层被分为`RuntimeException`和其他异常（比如：`IOException`）

Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查（unchecked）异常，所有的其他的异常称为受查（checked)异常

### 抛出异常
一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器可能发生什么错误。方法应该在其首部声明所有可能抛出的异常。

什么情况下，必须抛出异常？
+ 调用一个抛出受查异常的方法
+ 程序运行过程中发现错误，并且利用throw语句抛出一个受查异常。

一个方法必须声明所有可能抛出的受查异常，而非受查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）

子类方法中声明的受查异常不能比超类方法中声明的异常更通用。特别需要说明的是，如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。

如何抛出异常？
+ 找到一个合适的异常类
+ 创建这个类的一个对象
+ 将对象抛出
```java
String readData(Scanner in) throws EOFException
{
	...
	while(...) {
		if (!in.hasNext()) {
			if (n < len) {
				String gripe = "Content-length: " + len + ", Received:" + n;
				throw new EOFException(gripe);
			}
		}
		...
	}
	return s;
}
```
### 创建异常类
在程序中，可能会遇到任何标准异常都没有能够充分地 描述清楚的问题。在这种情况下，创建自己的异常类就是一件顺理成章的事情了。
```java
class FileFormatException extends IOException
{
	public FileFormatException(){}
	public FileFormatException(String gripe)
	{
		super (gripe);
	}
}
```
**java.lang.Throwable**
+ `Throwable()` 构造一个新的Throwable对象，这个对象没有详细的描述信息。
+ `Throwable(String message)` 构造一个新的throwable对象，这个对象带有特定的详细描述信息。习惯上，所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。
+ `String getMessage()`获得Throwable对象的描述信息。

### 捕获异常
应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。要想捕获一个异常，必须设置try/catch语句块。如果在try语句块中的任何代码抛出了一个在catch子句中说明的异常类，那么程序将跳过try语句块的其余代码，执行catch子句中的处理器代码。
```java
publi void read(String filename)
{
	try {
		InputStream in = new FileInputStream(filename);
		int b;
		while (b = in.read() != -1) {
			process input
		}
	} catch(IOException exception) {
		exception.printStackTrace();
	}
}
```
**注：** 如果编写一个覆盖超类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个受查异常。

在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。
```java
try {
	code that might throw exceptions
} catch(FileNotFoundException e) {
	emergency action for missing files
} catch(UnknownHostException e) {
	emergency action for unknown hosts
} catch(IOException e) {
	emergency action for all other I/O problems
}
```

在JavaSE7中，同一个catch子句中，可以==捕获多个异常类型==。只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。
```java
try {
	code that might throw exceptions
} catch (FileNotFoundException | UnknownHostException e) {
	emergency action for missing files and unknown hosts 
} catch(IOException e) {
	emergency action for all other I/O problems
}
```
**注：** 捕获多个异常时，异常变量隐含为==final变量==。所以，不能为e赋值。
### 异常链
在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。
```java
try {
	access the database
} catch (SQLException) {
	throw new ServletException("database error: " + e.getMessage());
}
```
不过，可以有一种更好的方法，并且将原始异常设置为新异常的“原因”：
```java
try {
	access the databse
} catch(SQLException e) {
	Throwable se = new ServletException("database error");
	se.initCase(e);
	throw se;
}
```
当捕获到异常时，就可以使用下面这条语句重新获得到原始异常：
```java
Throwable e = se.getCause()
```
强烈建议使用这种包装技术，这样就可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。

如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用。我们可以捕获这个受查异常，并将它包装成一个运行时异常。
### finally
当代码抛出一个异常时，并且方法获得了一些本地资源，那么就会产生资源回收问题。

在下面的示例中，程序将在所有情况下关闭文件。
```java
InputStream in = new FileInputStream(...);
try { 
	...
	code that might throw exceptions
	...
} catch (IOException e) {
	...
	show error message
	...
} finally {
	...
	in.close();
}
```

这里，强烈建议解耦合try/catch和try/finally语句块。这样可以提高代码的清晰度。
```java
InputStream in = ...;
try {
	try {
		code that might throw exceptions
	} finally {
		in.close();
	}
} catch(IOException e) {
	show error message
}
```
内层的try语句块只有一个职责，就是确保关闭输入流。外层的try语句块就是确保报告出现的错误。这种设计方式不仅清楚，而且还具有一个功能，就是将会报告finally子句中出现的错误。

当finally子句包含return语句时，将会出现一种意想不到的结果。假设利用return语句从try语句块中退出。在方法返回前，finally子句的内容将被执行。如果finally子句中也有一个return语句，这个返回值将会覆盖原始的返回值。

### 带资源的try语句
如果try块抛出一个异常，而且close方法也抛出一个异常，这就会带来一个难题。带资源的try语句可以很好地处理这种情况。原来的异常会重新抛出，而close方法 抛出的异常会被"被抑制"。这些异常将自动捕获，并由addSuppressed方法增加到原来的异常。可以调用getSuppressed方法，它会得到从close方法抛出并被抑制的异常列表。
```java
try (Scanner in = new Scanner(new FinleInputStream("/usr/share/dict/words"), "UTF-8"); 
	PrintWriter out = new PrintWriter("out.txt")) {
	while (in.hasNext()) {
		out.println(in.next().toUpperCase());
	}
}
```
不论这个块如何退出，in和out都会关闭。