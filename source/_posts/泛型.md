---
title: 泛型
date: 2021-05-05 13:32:50
categories: 
- Java
tags:
---

## 泛型类

一个泛型类就是具有一个或多个类型变量的类。
```java
public class Pair<T> {
	private T first;
	private T second;
	public Pair() {first = null; second = null;}
	public Pair(T first, T second) {this.first = first; this.second = second;}
	public T getFirst() {return first;}
	public T getSecond() {return second;}
	public void setFirst(T newValue) {fisrt = newValue;}
	public void setSecond(T newValue) {second = newValue;}
}
```

泛型类可以有多个类型变量，如下面的例子：
```java
public class Pair<T, U> {...}
```

## 泛型方法
泛型方法可以定义在普通类中，也可以定义在泛型类中。

下面的例子，从尖括号和类型变量可以看出，是一个泛型方法。 类型变量放在修饰符（这里是`public static`）后面，返回类型前面。

```java
class ArrayAlg {
	public static <T> T getMiddle(T... a) {
		return a[a.length / 2];
	}
}
```

## 类型变量的限定
有时，类或方法需要对类型变量加以约束。

比如下面的例子，计算数组中的最小元素。将T限制为实现了Comparable接口的类，可以通过对类型变量T设置限定实现这一点。
```java
class ArrayAlg {
	public static <T extends Comparable> T min(T[] a) {
		if (a == null || a.length == 0) return null;
		T smllest = a[0];
		for (int i = 1; i < a.length; i++) {
			if (smallest.compareTo(a[i] > 0) smallest = a[i];
		}
		return smallest;
	}
}
```
一个类型变量或或通配符可以有多个限定。限定类型用`&`分隔，而逗号用来分隔类型变量。
```java
T extends Comparable & Serializable
```

## 泛型代码和虚拟机
虚拟机没有泛型类对象，所有对象都属于普通类。

### 类型擦除
无论何时定义一个泛型类，都自动提供了一个相应的原始类型。原始类型的名字就是删除类型参数后的泛型类型名。擦除类型变量，并替换为第一个限定类型（无限定的变量用Object）
```java
public class Pair
{
	private Object first;
	private Object second;
	public Pair() {first = null; second = null;}
	public Pair(Object first, Object second) {this.first = first; this.second = second;}
	public Object getFirst() {return first;}
	public Object getSecond() {return second;}
	public void setFirst(Object newValue) {fisrt = newValue;}
	public void setSecond(Object newValue) {second = newValue;}
}
```

### 翻译泛型表达式
当程序调用泛型方法时，如果擦除返回类型，编译器插入强制类型转换。比如下面的这个例子：
```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```
擦除getFirst的返回类型后将返回Object类型。编译器自动插入 Employee的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：
+ 对原始方法Pair.getFirst的调用。
+ 将返回的Object类型强制转换为Employee类型。

### 翻译泛型方法
类型擦除也会出现在泛型方法中。比如下面的例子：

```java
class DateInterval extends Pair<LocalDate> {
	public void setSecond(LocalDate second) {...}
	...
}
```
将其类型擦除后：
```java
class DateInterval extends Pair {
	public void setSecond(LocalDate second) {...}
	...
}
```
现在的问题是：存在另一个从Pair继承的setSecond方法。
```java
public void setSecond(Object second)
```
这样的话，类型擦除与多态就发生了冲突。要解决这个问题，就需要编译器在DateInterval类中生成一个桥方法。
```java
public void setSecond(Object second) {
	setSecond((Date) second);
}
```
不能这样编写Java代码（在这里，具有相同参数类型的两个方法是不合法的），它们都没有参数。但是在虚拟机中，用参数类型和返回类型决定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确的处理这一情况。

其实，桥方法不仅用于泛型类型，在一个方法覆盖另一个方法时可以至指定一个更严格的返回类型。

## 类型通配符

